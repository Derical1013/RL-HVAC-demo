<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>Professional RL-HVAC Demo</title>
    <style>
        /* 布局样式保持大尺寸 */
        body { font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; background: #f0f2f5; display: flex; flex-direction: column; align-items: center; padding: 20px; }
        .dashboard { background: white; padding: 30px; border-radius: 20px; box-shadow: 0 8px 30px rgba(0,0,0,0.12); display: flex; gap: 30px; max-width: 1300px; width: 100%; }
        .room-view { width: 480px; display: flex; flex-direction: column; align-items: center; border-right: 2px solid #eee; padding-right: 30px; }
        .charts-view { flex: 1; display: flex; flex-direction: column; justify-content: center; }
        
        canvas { border: 1px solid #ccc; background: #fdfdfd; border-radius: 8px; margin-bottom: 20px; display: block; }
        
        h2 { font-size: 28px; margin-bottom: 20px; color: #222; }
        h3 { margin: 10px 0 5px 0; color: #444; font-size: 20px; }
        
        button { background: #007bff; color: white; border: none; padding: 15px 30px; border-radius: 8px; cursor: pointer; font-size: 20px; font-weight: bold; transition: 0.3s; width: 100%; margin-top: 20px; box-shadow: 0 4px 6px rgba(0,123,255,0.2); }
        button:hover { background: #0056b3; transform: translateY(-2px); }
        button.occupied { background: #28a745; box-shadow: 0 4px 6px rgba(40,167,69,0.2); }
        button.occupied:hover { background: #218838; }
        
        .status-badge { padding: 8px 20px; border-radius: 30px; font-size: 18px; font-weight: bold; margin-bottom: 20px; display: inline-block; }
        .status-eco { background: #e6f4ea; color: #1e8e3e; border: 2px solid #1e8e3e; }
        .status-comfort { background: #e8f0fe; color: #1967d2; border: 2px solid #1967d2; }
        
        .legend { font-size: 14px; color: #666; display: flex; gap: 20px; margin-bottom: 10px; }
        .dot { width: 14px; height: 14px; display: inline-block; border-radius: 50%; margin-right: 8px; vertical-align: middle; }
        .info-text { text-align: left; width: 100%; margin-top: 15px; font-size: 16px; line-height: 1.6; color: #555; }
        .info-text span { font-weight: bold; }
    </style>
</head>
<body>

    <h2>RL-HVAC Direct Power Control Demo</h2>
    <div class="dashboard">
        <div class="room-view">
            <div id="modeBadge" class="status-badge status-eco">MODE: ECO (Energy Saving)</div>
            <canvas id="roomCanvas" width="450" height="450"></canvas>
            
            <div class="info-text">
                <p><strong>Current State:</strong></p>
                <p>Occupancy: <span id="occText" style="color: gray;">NO</span></p>
                <p>Comfort Weight (λ): <span id="weightText">Low</span></p>
                <p>Constraint: <span id="constraintText">Relaxed</span></p>
            </div>

            <button id="toggleBtn" onclick="toggleOccupancy()">Simulate Person Entering</button>
        </div>

        <div class="charts-view">
            <h3>Indoor Temperature (°C)</h3>
            <div class="legend">
                <span><span class="dot" style="background:#ff4444"></span>Temp</span>
                <span><span class="dot" style="background:rgba(40, 167, 69, 0.2); border:1px solid #999"></span>Comfort Range</span>
            </div>
            <canvas id="tempChart" width="800" height="220"></canvas>

            <h3>HVAC Power Output (%)</h3>
            <div class="legend">
                <span><span class="dot" style="background:#007bff"></span>Power Action</span>
            </div>
            <canvas id="powerChart" width="800" height="220"></canvas>
        </div>
    </div>

    <script>
        // --- 仿真参数 ---
        let isOccupied = false;
        let time = 0;
        let indoorTemp = 26.0;
        let ambientTemp = 33.0; 
        const coolingPowerMax = 0.25; 
        const heatLeakage = 0.01; 
        let targetTemp = 24.0;
        let currentPower = 0.0;
        let upperLimit = 28.0;
        let lowerLimit = 20.0;

        // 数据记录
        const maxDataPoints = 300;
        let tempData = new Array(maxDataPoints).fill(26);
        let powerData = new Array(maxDataPoints).fill(0);
        let limitData = new Array(maxDataPoints).fill({upper: 28, lower: 20});

        // Canvas
        const roomCanvas = document.getElementById('roomCanvas');
        const roomCtx = roomCanvas.getContext('2d');
        const tempCanvas = document.getElementById('tempChart');
        const tempCtx = tempCanvas.getContext('2d');
        const powerCanvas = document.getElementById('powerChart');
        const powerCtx = powerCanvas.getContext('2d');

        // --- 布局参数 (解决坐标轴问题的关键) ---
        const layout = {
            paddingLeft: 60,  // 给左边文字留 60px
            paddingRight: 20,
            paddingTop: 20,   // 给顶部留 20px 防止切字
            paddingBottom: 20
        };

        // --- 核心逻辑 ---
        function updateSimulation() {
            indoorTemp += (ambientTemp - indoorTemp) * heatLeakage;
            indoorTemp -= currentPower * coolingPowerMax;
            indoorTemp += (Math.random() - 0.5) * 0.05;

            if (isOccupied) {
                let error = indoorTemp - targetTemp;
                let desiredPower = (error * 1.8) + 0.35; 
                if (desiredPower > currentPower + 0.025) currentPower += 0.025;
                else if (desiredPower < currentPower - 0.025) currentPower -= 0.025;
                else currentPower = desiredPower;
                upperLimit = 24.4; lowerLimit = 23.6;
            } else {
                upperLimit = 28.0; lowerLimit = 20.0;
                if (indoorTemp > upperLimit - 0.3) currentPower = 0.25;
                else currentPower = 0.0; 
            }
            currentPower = Math.max(0, Math.min(1, currentPower));

            tempData.push(indoorTemp); tempData.shift();
            powerData.push(currentPower); powerData.shift();
            limitData.push({upper: upperLimit, lower: lowerLimit}); limitData.shift();
            time++;
        }

        // --- 绘图逻辑 ---
        function draw() {
            roomCtx.clearRect(0, 0, roomCanvas.width, roomCanvas.height);
            tempCtx.clearRect(0, 0, tempCanvas.width, tempCanvas.height);
            powerCtx.clearRect(0, 0, powerCanvas.width, powerCanvas.height);

            drawRoom();
            drawChart(tempCtx, tempCanvas, tempData, limitData, 18, 34, "°C", true);
            drawChart(powerCtx, powerCanvas, powerData, null, 0, 1, "%", false); // Power 0-1

            requestAnimationFrame(animate);
        }

        function animate() { updateSimulation(); draw(); }

        // --- 画图表 (通用函数，带 Padding) ---
        function drawChart(ctx, canvas, data, limits, minVal, maxVal, unit, isTemp) {
            let W = canvas.width;
            let H = canvas.height;
            // 计算绘图区域的宽高
            let graphW = W - layout.paddingLeft - layout.paddingRight;
            let graphH = H - layout.paddingTop - layout.paddingBottom;

            // 1. 画网格和坐标轴
            ctx.strokeStyle = "#e0e0e0";
            ctx.lineWidth = 1;
            ctx.fillStyle = "#666";
            ctx.font = "bold 14px Arial";
            ctx.textAlign = "right";
            ctx.textBaseline = "middle"; // 垂直居中，防止切字

            let lines = 5;
            for (let i = 0; i < lines; i++) {
                let y = layout.paddingTop + i * (graphH / (lines - 1));
                
                // 网格线
                ctx.beginPath();
                ctx.moveTo(layout.paddingLeft, y);
                ctx.lineTo(W - layout.paddingRight, y);
                ctx.stroke();

                // 坐标数值
                let val = maxVal - (i / (lines - 1)) * (maxVal - minVal);
                if (!isTemp) val *= 100; // Power 转 %
                ctx.fillText(Math.round(val) + unit, layout.paddingLeft - 10, y);
            }

            // 2. 画舒适区 (仅 Temperature)
            if (limits) {
                ctx.fillStyle = isOccupied ? "rgba(0, 123, 255, 0.15)" : "rgba(40, 167, 69, 0.1)";
                ctx.beginPath();
                // 上边界
                let firstY = map(limits[0].upper, minVal, maxVal, graphH, 0) + layout.paddingTop;
                ctx.moveTo(layout.paddingLeft, firstY);
                
                for (let i = 0; i < maxDataPoints; i++) {
                    let x = layout.paddingLeft + i * (graphW / maxDataPoints);
                    let y = map(limits[i].upper, minVal, maxVal, graphH, 0) + layout.paddingTop;
                    ctx.lineTo(x, y);
                }
                // 下边界 (倒着画回来闭合)
                for (let i = maxDataPoints - 1; i >= 0; i--) {
                    let x = layout.paddingLeft + i * (graphW / maxDataPoints);
                    let y = map(limits[i].lower, minVal, maxVal, graphH, 0) + layout.paddingTop;
                    ctx.lineTo(x, y);
                }
                ctx.fill();
            }

            // 3. 画数据曲线
            ctx.beginPath();
            ctx.lineWidth = 3;
            ctx.strokeStyle = isTemp ? "#ff4444" : "#007bff";
            if (!isTemp) ctx.fillStyle = "rgba(0, 123, 255, 0.2)"; // Power 加填充
            
            // 移动到第一个点
            let startY = map(data[0], minVal, maxVal, graphH, 0) + layout.paddingTop;
            ctx.moveTo(layout.paddingLeft, startY);

            for (let i = 0; i < maxDataPoints; i++) {
                let x = layout.paddingLeft + i * (graphW / maxDataPoints);
                let y = map(data[i], minVal, maxVal, graphH, 0) + layout.paddingTop;
                ctx.lineTo(x, y);
            }

            if (!isTemp) {
                // Power图闭合底部以填充颜色
                ctx.lineTo(layout.paddingLeft + graphW, layout.paddingTop + graphH);
                ctx.lineTo(layout.paddingLeft, layout.paddingTop + graphH);
                ctx.fill();
            }
            ctx.stroke();
        }

        // --- 画房间 (不变) ---
        function drawRoom() {
            // 简单重绘逻辑，与之前类似，但坐标系调整
            roomCtx.lineWidth = 4;
            roomCtx.strokeStyle = "#555";
            roomCtx.strokeRect(50, 80, 350, 280);
            roomCtx.fillStyle = "#e0e0e0";
            roomCtx.fillRect(50, 360, 350, 20);

            let acPowerColor = currentPower > 0.05 ? "#007bff" : "#bbb";
            roomCtx.fillStyle = acPowerColor;
            roomCtx.fillRect(150, 80, 150, 40);

            if (currentPower > 0.05) {
                let alpha = 0.2 + currentPower * 0.5;
                let spread = currentPower * 60;
                let gradient = roomCtx.createLinearGradient(225, 120, 225, 350);
                gradient.addColorStop(0, `rgba(0, 123, 255, ${alpha})`);
                gradient.addColorStop(1, "rgba(255, 255, 255, 0)");
                roomCtx.fillStyle = gradient;
                roomCtx.beginPath();
                roomCtx.moveTo(160, 120);
                roomCtx.lineTo(100 - spread, 350);
                roomCtx.lineTo(350 + spread, 350);
                roomCtx.lineTo(290, 120);
                roomCtx.fill();
            }

            if (isOccupied) {
                drawBigPerson(roomCtx, 225, 280, "#333");
                roomCtx.fillStyle = "#28a745";
                roomCtx.font = "bold 24px Arial";
                roomCtx.textAlign = "center";
                roomCtx.fillText("OCCUPIED", 225, 420);
            } else {
                roomCtx.fillStyle = "#aaa";
                roomCtx.font = "italic 24px Arial";
                roomCtx.textAlign = "center";
                roomCtx.fillText("UNOCCUPIED", 225, 420);
            }
        }

        // --- 工具函数 ---
        function map(value, inMin, inMax, outMax, outMin) { // 注意 outMin 和 outMax 顺序换了，方便计算
            return (value - inMin) * (outMin - outMax) / (inMax - inMin) + outMax;
        }

        function toggleOccupancy() {
            isOccupied = !isOccupied;
            const btn = document.getElementById('toggleBtn');
            const badge = document.getElementById('modeBadge');
            const occText = document.getElementById('occText');
            const weightText = document.getElementById('weightText');
            const constraintText = document.getElementById('constraintText');

            if (isOccupied) {
                btn.innerText = "Simulate Person Leaves Room";
                btn.className = "occupied";
                badge.innerText = "MODE: COMFORT (Precision Control)";
                badge.className = "status-badge status-comfort";
                occText.innerText = "YES"; occText.style.color = "#28a745";
                weightText.innerText = "High (Strict)";
                constraintText.innerText = "Smoothness Priority";
            } else {
                btn.innerText = "Simulate Person Enters Room";
                btn.className = "";
                badge.innerText = "MODE: ECO (Energy Saving)";
                badge.className = "status-badge status-eco";
                occText.innerText = "NO"; occText.style.color = "gray";
                weightText.innerText = "Low / Zero";
                constraintText.innerText = "Relaxed";
            }
        }

        function drawBigPerson(ctx, x, y, color) {
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(x, y-30, 18, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.moveTo(x - 25, y - 10);
            ctx.lineTo(x + 25, y - 10);
            ctx.quadraticCurveTo(x + 35, y - 10, x + 35, y + 10);
            ctx.lineTo(x + 30, y + 70);
            ctx.quadraticCurveTo(x + 30, y + 80, x, y + 80);
            ctx.quadraticCurveTo(x - 30, y + 80, x - 30, y + 70);
            ctx.lineTo(x - 35, y + 10);
            ctx.quadraticCurveTo(x - 35, y - 10, x - 25, y - 10);
            ctx.fill();
        }

        animate();
    </script>
</body>
</html>
